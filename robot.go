package main

import (
	"fmt"
	"strings"

	sdk "github.com/opensourceways/go-gitee/gitee"
	"github.com/opensourceways/server-common-lib/config"
	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/util/sets"

	"github.com/opensourceways/robot-gitee-lib/framework"
)

const (
	botName = "cve-issue-suspending-check"

	issueStateOpen   = "open"
	issueStateChange = "state_change"

	reasonCommand = "/reason"
)

var (
	noReasonComment = `
@%s
**issue变更为 [%s] 状态时，必须填写相关原因，现issue被重新打开**
**请按如下格式评论原因后，重新进行操作**
*********************************
/reason xxxxxx
`

	withReasonComment = `
| issue状态  | 操作者 | 原因 |
|:--:|:--:|---------|
|%v|%v|%v|
`
)

type iClient interface {
	CreateIssueComment(org, repo string, number string, comment string) error
	ListIssueComments(org, repo, number string) ([]sdk.Note, error)
	UpdateIssue(owner, number string, param sdk.IssueUpdateParam) (sdk.Issue, error)
	GetBot() (sdk.User, error)
}

func newRobot(cli iClient) (*robot, error) {
	bot, err := cli.GetBot()
	if err != nil {
		return nil, err
	}

	return &robot{
		cli:  cli,
		name: bot.Login,
	}, nil
}

type robot struct {
	cli  iClient
	name string
}

func (bot *robot) NewConfig() config.Config {
	return &configuration{}
}

func (bot *robot) RegisterEventHandler(f framework.HandlerRegister) {
	f.RegisterIssueHandler(bot.handleIssueEvent)
}

func (bot *robot) handleIssueEvent(e *sdk.IssueEvent, c config.Config, log *logrus.Entry) error {
	cfg, b := bot.canApply(e, c)
	if !b {
		return nil
	}

	reason, err := bot.getReason(e)
	if err != nil {
		return err
	}

	org, repo := e.GetOrgRepo()
	var content string
	if reason != "" {
		content = fmt.Sprintf(withReasonComment,
			e.GetIssue().GetStateName(), e.GetUpdatedBy().GetLogin(), reason)

		return bot.cli.CreateIssueComment(org, repo, e.GetIssueNumber(), content)
	}

	_, err = bot.cli.UpdateIssue(org, e.GetIssueNumber(), sdk.IssueUpdateParam{
		Repo:  repo,
		State: issueStateOpen,
	})
	if err != nil {
		return err
	}

	content = fmt.Sprintf(noReasonComment,
		e.GetUpdatedBy().GetLogin(), strings.Join(cfg.IssueState, "/"))
	return bot.cli.CreateIssueComment(org, repo, e.GetIssueNumber(), content)
}

func (bot *robot) canApply(e *sdk.IssueEvent, c config.Config) (bc *botConfig, b bool) {
	cfg, ok := c.(*configuration)
	if !ok {
		return
	}

	bc = cfg.configFor(e.GetRepository().GetNameSpace(), e.GetRepository().GetPath())
	if bc == nil {
		return
	}

	if e.GetAction() != issueStateChange {
		return
	}

	issueTypeSets := sets.NewString(bc.IssueType...)
	if !issueTypeSets.Has(e.GetIssue().GetTypeName()) {
		return
	}

	issueStateSets := sets.NewString(bc.IssueState...)
	b = issueStateSets.Has(e.GetIssue().GetStateName())

	return
}

func (bot *robot) getReason(e *sdk.IssueEvent) (reason string, err error) {
	org, repo := e.GetOrgRepo()
	comments, err := bot.cli.ListIssueComments(org, repo, e.GetIssueNumber())
	if err != nil {
		return
	}

	for i := len(comments) - 1; i >= 0; i-- {
		comment := comments[i]
		if comment.User.Login == bot.name {
			continue
		}

		body := comment.Body
		index := strings.Index(body, reasonCommand)
		if index == -1 {
			continue
		}

		reason = strings.TrimSpace(body[index+len(reasonCommand):])

		break
	}

	return
}
